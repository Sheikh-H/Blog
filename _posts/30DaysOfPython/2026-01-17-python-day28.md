---
layout: post
title: APIs (Application Programming Interfaces) â€“ Understanding HTTP and CRUD Operations
description: >-
  In this learning journal, I explore how APIs work, how HTTP requests and responses are structured, and how these concepts connect to real-world applications. From understanding headers and status codes to filtering data and mapping CRUD operations, I reflect on my journey learning how web systems communicate behind the scenes.
author: Sheikh Hussain
date: 2025-12-17 17:00:00 +0000
categories: [Python Course, 30 Days of Python - Asabeneh]
tags: [python, programming, course, 30days, day28, API, HTTP, Networking]
pin: false
math: false
mermaid: false
render_with_liquid: false
media_subpath: /assets/img/posts/
---

## What Is an API?

You can think of an <abbr title = "Application Programming Interface">API</abbr> as being a method that allows two separate systems to communicate with each other. The API is what allows the system/software to **automatically** send and receive requests.

A more detailed example would be to think of services like weather applications, delivery updates, or mobile application requests. In all these examples, the application doesn't store data and instead uses another system for data handling.

# Introduction to HTTP

To deepen my understanding of APIs, I took to contemplating about what I had learnt on <abbr title = "Hyper-Text Transfer Protocol">HTTP</abbr> and how a _request_ is made over the web and received. HTTP defines how information is relayed between a client (system, application, or browser) and a server.

Whenever we visit a website or search for something online or in a website, our browsers are sending a **HTTP request** with the information we want and the server is what replies with a **HTTP response** containing all the information.

# HTTP Requests

This is what a basic HTTP request looks like:

```http
GET /students HTTP/1.1
Host: example.com
Accept: application/json
...
```

From this, I can identify:

**GET** - the HTTP Method (requesting data)
**/students** - the resource being requested
**HTTP/1.1** - the HTTP protocol version
**Headers** - extra information about the request

This request is asking the server to return a list of students in JSON format.

## What are HTTP Methods

**HTTP Methods** will seem very similar to database CRUD (Create, Read, Update, Delete) operations, and that's with intent. Each CRUD operation works with an HTTP method to ensure the action is performed correctly.

Here is a mental map that I can use to grasp the concept:

GET - Read data (Read)
POST - Create new data (Create)
PUT - Replace existing data (Update)
PATCH - Update part of existing data (Update)
DELETE - Remove data (Delete)

## HTTP Responses

When a server sends a response, it typically includes:

1. A status code (200, 404, etc.)
2. Headers
3. A response body (the actual data)

Here's an example of an HTTP response:

```http
HTTP/1.1 200 OK
Content-Type: application/json

[
  {"name": "Sheikh Hussain", "grade": "C"},
  {"name": "John Doe", "grade": "B"}
]
```

The key information presented here is the `HTTP/1.1 200 OK` part, as this includes the status code. I've already discussed what all the status codes are in another post, but `200 OK` means the request was successful.

## Understanding HTTP Headers

**HTTP headers** are metadata on the request or response made. Think of them as additional bits of information that explain _how_ the data should be handled.

Here are some:

Host - which server is being contacted
Accept - what type of data the client expects
Content-Type - what type of data is being sent back

There are many more that I could include, but this is enough.

## A More Granular Example

The earlier example of an HTTP request was made for a whole collection/table of data. What if we wanted specific information from the server?

Think about the time when we use search filters on sites and how they produce a list of results. For that, the HTTP request is made to be more detailed.

_Get all the students' names and age fields who got a grade C_:

```http
GET /students?grade=C&fields=name,age HTTP/1.1
```

## A Realistic HTTP Request Example

To make sure I understood all about HTTP requests and responses, I wanted to include an actual example that was placed in the course contents. This should give a better idea of what an actual request should look like.

```http
GET / HTTP/1.1
Host: thirtydaysofpython-v1-final.herokuapp.com
Connection: keep-alive
Pragma: no-cache
Cache-Control: no-cache
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.79 Safari/537.36
Sec-Fetch-User: ?1
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: navigate
Referer: https://thirtydaysofpython-v1-final.herokuapp.com/post
Accept-Encoding: gzip, deflate, br
Accept-Language: en-GB,en;q=0.9,fi-FI;q=0.8,fi;q=0.7,en-CA;q=0.6,en-US;q=0.5,fr;q=0.4
```

I haven't explored all the header metadata information just yet, but most of them do seem self-explanatory.

## What Happens Before a Response is Sent?

I wanted to include this topic as being or forming part of this module in the course, as this information helps to comprehend the information better. Before an HTTP request is made from the client to the server, a connection must be created.

This is done using what is known as a **3-way TCP Handshake**. Before I explain a TCP handshake, I would also have to also go over what TCP/IP is.

In computer networking, we come across the term <abbr title="Transmission Control Protocol / Internet Protocol">TCP/IP</abbr>, which illustrates what the different layers within a network are. We also learn about <abbr title = "Open Systems Interconnectivity">OSI</abbr> model, which is often described as being an extension to the TCP/IP model.

### TCP/IP and OSI Model

Before any communication is sent over a network, there are protocols set in place to ensure all information is sent and received _reliably_. It's important to understand this information as it helps later.

Each layer performs a set of instructions on the data or network and then sends out the data as packets.

Here is an image that describes both models, if you'd like to learn about the OSI and TCP/IP models, I would recommend visiting the web. I want to stay on topic for my posts.

![TCP/IP Model - Geeks For Geeks](https://media.geeksforgeeks.org/wp-content/uploads/20251215161450630019/osi-to-tcp.webp)

### 3-Way TCP Handshake

At a high-level, during the TCP/IP or OSI protocols a _sub-request_ is sent to the server to ensure that the server is okay to receive a request and send a response. This is often where you would come across _server timed out_ errors.

All that happens is, the client sends a synchronise request, receives a synchronise and acknowledge response, and sends back an acknowledge is sent from the client back to the server.

This diagram should help with visualising the concept:
![3-Way TCP Handshake - Geeks for Geeks](https://media.geeksforgeeks.org/wp-content/uploads/handshake-1.png)

This is a topic for another time, but it can get very in-depth and I would suggest consuming as much content as possible on this to get the complete picture.

## Summary

With all that discussed, that sums up today's work. I know it seems less practical and more theoretical for a change; however, it's good information that we can think on when brainstorming on how your everyday browser and applications work.

This insight alone promotes creative thinking for me as it starts to highlight how data is being sent and received, and what types of data are available. I should keep in mind here that while I have been discussing the majority of my examples around database queries, we use the same methods to send and receive images, videos, documents, and many other file formats.

To include some more interesting information, when we play video games over an online server or have a video call with someone. We don't use the 3-way handshake, and instead we use a <abbr title = "User Datagram Protocol">UDP</abbr>, which just send the information in a stream-like form.
